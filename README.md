# clean_arch_bookly_app_v1

A new Flutter project.

## Getting Started

دراسة متعمقة لمبادئ المعماريه النظيفة في فلاتر وتطبيقها على تصميم التطبيقات [باللغة العربية]


Description
This course on clean architecture in Flutter will take you on a step-by-step journey through building a scalable and maintainable Flutter application using clean architecture principles.

The course will begin with an introduction to clean architecture principles and how they can help you build more efficient and maintainable Flutter applications.

The course will then focus on the presentation layer, where you will learn how to design and implement a clean and responsive user interface using Flutter widgets and state management techniques.

Next, the course will move on to the domain layer, where you will learn how to define the business logic and use cases of your application using clean architecture principles.

Then, the course will cover the data layer, where you will learn how to fetch and store data from different sources using repositories, data sources, and data models.

Finally, the course will cover the integration between the presentation layer and the domain layer, where you will learn how to connect the two layers using dependency injection and inversion of control principles to build a clean and maintainable Flutter application.

Throughout the course, you will also learn best practices for testing, debugging, and profiling your Flutter application to ensure its correctness, reliability, and performance.

By the end of this course, you will have a solid understanding of clean architecture principles and be able to apply them to build efficient, scalable, and maintainable Flutter applications.



Ce que vous allez apprendre
Understanding the principles of clean architecture and its importance in building scalable and maintainable Flutter applications
Designing and implementing the layers of clean architecture, including the domain layer, use cases, and presentation layer
Applying dependency injection and inversion of control principles to improve testability and maintainability of the application.
Using reactive programming and state management techniques to build responsive and efficient Flutter applications
Applying best practices for debugging, profiling, and optimizing clean architecture Flutter applications for improved performance and user experience.
Y a-t-il des exigences ou prérequis pour ce cours ?
Basic to medium level of knowledge in Flutter development, including a good understanding of Dart programming language, widget tree hierarchy, and state management techniques
Access to a computer with Flutter SDK and development tools installed to practice coding and building applications.
Willingness to learn and a passion for building high-quality, scalable, and maintainable Flutter applications
À qui ce cours s'adresse-t-il ?
Any developer who already have a basic to medium level of knowledge in Flutter development and want to take their skills to the next level. They could be software developers, mobile app developers, or anyone interested in building high-quality, scalable, and maintainable Flutter applications. Learners who are familiar with software design patterns, object-oriented programming principles, and test-driven development concepts will find this course particularly valuable. Additionally, learners who are interested in improving their knowledge of reactive programming and state management techniques in Flutter will benefit from this course. By the end of this course, learners should have a solid understanding of clean architecture principles and be able to apply them to build efficient and maintainable Flutter applications
# UDEMY
https://www.udemy.com/course/deep-dive-into-clean-architecture-in-flutter-2022arabic/
# GITHUB
https://github.com/tharwatsamy/clean_arch_bookly_app.git


# Section 2 Presentation Building the UI
6. Creating and structuring our project
7. Create splash view body
8. Splash view body
9. Splash view body done
10. change theme
# https://github.com/tharwatsamy/my_bookly/commit/4e89af34e0e923d06f77551178ff7ba816b349e7
11. Adding animation

# refactor init satate & navigate to home
https://github.com/tharwatsamy/my_bookly/commit/db04cb86e3e388476bff2e6931a62dc6e54e491c#diff-98de3b22ccfee31379cff73c6d785a5754eed5e6387f8d2437d1fb6617730a39
12. Refactor code

# add custom app bar to home view
https://github.com/tharwatsamy/my_bookly/commits/main?after=f4820be98b36e4988d2ce5650e295f9bde60eb1c+34&branch=main&qualified_name=refs%2Fheads%2Fmain
13. Create custom app bar
# add custom list view item to home
https://github.com/tharwatsamy/my_bookly/commit/1cf2cbd6c984628c4d8faedbe3c5ac4634fbd9c5
14. Featured list view item
# add featured list view to home
https://github.com/tharwatsamy/my_bookly/commit/d0bdef9718d95dd711f1a68d3595ecf3dedd1fe6
15. Featured list view
# create styles file & add best seller text
https://github.com/tharwatsamy/my_bookly/commit/418057ccedbb608ca439c2f70063a7ac9a0ac85a
16. Add styles file and text to home

# create styles file and add title to home view
https://github.com/tharwatsamy/my_bookly/commit/fc39a8beb15d20ea609568d184940d5fb54f1411
17. add font family
# best seller list view item part one
https://github.com/tharwatsamy/my_bookly/commit/2bb0a08e16322093dc1c9be2c846442806645cc3
18. Best seller list view item part one
# 
19. Install font family
# create app styles
https://github.com/tharwatsamy/my_bookly/commit/2e1db9e11a244125e7c5f39d404df23f855b0806
20. styles part one
# create app styles
https://github.com/tharwatsamy/my_bookly/commit/2e1db9e11a244125e7c5f39d404df23f855b0806
21. Styles part two
# best sellert item part 2
https://github.com/tharwatsamy/my_bookly/commit/d8aa14953ceaad834c69c993e2d9b0ac2605238f
22. Best seller item part 2
# best sellert item part 3
https://github.com/tharwatsamy/my_bookly/commit/6f89760b873eacc32f28e92c82bfd1622287e768
23. Best seller item part 3
# best sellert item done
https://github.com/tharwatsamy/my_bookly/commit/cc32c155d37f0659b24348708ffd8e57128eb2fe
24. Best seller item done
# best seller list view done
https://github.com/tharwatsamy/my_bookly/commit/0c5ba7648ce9a391bafd9ea5f3a1554c515e9e1f
25. Best seller list view & Custom scroll view
# create book_details_view.dart
https://github.com/tharwatsamy/my_bookly/commit/09e6618464c2ae6f34ff7bd882ea6565ab9cb892
26. Create book details view
# refactor navigation in our app
https://github.com/tharwatsamy/my_bookly/commit/a031d9ea2d7e9916f2d2327fd9c03f401f488da3
27. Refactor navigation
# create custom book details app bar
https://github.com/tharwatsamy/my_bookly/commit/2a1c27ace537f8be28ead9b6c495d59e0b153f91
28. Create custom book details app bar
# add custom book item to book details view
https://github.com/tharwatsamy/my_bookly/commit/55dab84378d78c775b6f748bea719f8024ca076c
29. Add Custom image to book details view
# add title to book details
https://github.com/tharwatsamy/my_bookly/commit/a8ddec3d147cc6a66ab3449be1155e6efc319cba 30. Add title and subTitle to book details view
# add rating to bool details
https://github.com/tharwatsamy/my_bookly/commit/ecfb45928dfe551358abe1dbea83c82241408a14
31. Add rating to book details
# create books action
https://github.com/tharwatsamy/my_bookly/commit/3e71b17b24597e97fd7a93e57e6806aabd6390bf
32. Create books button action
# create similar books list view
https://github.com/tharwatsamy/my_bookly/commit/193f956d3e814f25ef6281e8a3a8efd6982c8442
33. Book details view done

#  
#  
# 
# 


# create book model
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/52e0617ab5947cc0c51152df0f2c44261f72ab12

36. Book entity
# https://medium.com/@fakhiradevina/flutter-tdd-clean-architecture-272373727699
Flutter TDD Clean Architecture
Three years studying computer science has taught me not only to put things on the code and be grateful if it works, but also to make sure the code I write today won’t hurt my eyes in the future. Just like in this pandemic time, it’s always necessary to clean your code (and hands!).

There are so much to learn about clean code. You can read it all on uncle Bob’s book, one thing to be highlighted for this article is to separate code into independent layers and depend on abstractions instead of concrete implementations. This article is going to explain the implementation of the flutter clean architecture in my current project bisaGo.
Implementing Reso Coder’s Clean Architecture
As you can see from the picture above, there are 3 layers of the architecture: Data, Domain, and Presentation. Each of them has its’ purpose and only can interact like the flow above; Data and Presentation can only talk to each other with the help of Domain. It’s pretty straight forward but still a bit abstract if we don’t implement it.

I’m going to give an example of implementing Search Location feature. Locations provided by the application are gathered in remote sources (REST API). When user clicked one of the location, the application needs to remember the past clicked location by retrieving the list from cookies.

1. Data
The Data layer consists of repository and data models. Repository is where the application gather all data related to the use case, either from local sources (Local DB, cookies) or remote sources (remote API). Data from the sources, usually in json format, is parsed to Dart object called models. It’s need to be done to make sure the application knows what data and variable it’s expecting.

So I created the LokasiRepository to gather all the data from different resources. Data from API is gathered with the fetchLokasi() function, and Data from cookie is gathered with the fetchRecentSearch() function.
import 'dart:convert';

import 'package:ppl_disabilitas/model/lokasi.dart';
import 'package:ppl_disabilitas/network/cookies_interface.dart';
import 'package:ppl_disabilitas/network/network_interface.dart';

class LokasiRepository {
  final _network = NetworkInterface();
  final _cookie = CookiesInterface();
  Future<LokasiListResponse> fetchLokasi() async {
    final response = await _network.get(
        url: 'https://my.api.mockaroo.com/mall.json?key=dbcde960',
        isLogin: false);
    return LokasiListResponse(
        response.map<Lokasi>((lokasi) => Lokasi.fromJson(lokasi)).toList());
  }

  Future<LokasiListResponse> fetchRecentSearch() async {
    var response;
    await _cookie
        .checkCookieFileAvailability(fileName: "searchhistory")
        .then((boolean) async {
      if (!boolean) {
        response = [];
      } else {
        try {
          await _cookie.getCookieFile(fileName: "searchhistory").then((cookie) {
            response = json.decode(cookie);
          });
        } on Exception{
          response = [];
        }
      }
    });
    return LokasiListResponse(
        response.map<Lokasi>((lokasi) => Lokasi.fromJson(lokasi)).toList());
  }
}
As you can see in line 14–15 and 35–36, all the functions return an object called LokasiListResponse that was made by the json data containing list of locations. Flutter makes it easier by using the Json Serializable package. You just have to create a model class consists of variables based on the data from the source, and then the package will generate a .g.dart file for you.
import 'package:json_annotation/json_annotation.dart';
part 'lokasi.g.dart';
@JsonSerializable()
class LokasiListResponse {
  List<Lokasi> listLokasi;

  LokasiListResponse(this.listLokasi);
}

@JsonSerializable(nullable: true)
class Lokasi {
  String nama;
  double latitude;
  double longitude;
  String alamat;
  String foto;
  String telepon;

  Lokasi();

  factory Lokasi.fromJson(Map<String, dynamic> json) => _$LokasiFromJson(json);
  Map<String, dynamic> toJson() => _$LokasiToJson(this);
}
// GENERATED CODE - DO NOT MODIFY BY HAND

part of 'lokasi.dart';

// **************************************************************************
// JsonSerializableGenerator
// **************************************************************************

LokasiListResponse _$LokasiListResponseFromJson(Map<String, dynamic> json) {
  return LokasiListResponse(
    (json['listLokasi'] as List)
        ?.map((e) =>
            e == null ? null : Lokasi.fromJson(e as Map<String, dynamic>))
        ?.toList(),
  );
}

Map<String, dynamic> _$LokasiListResponseToJson(LokasiListResponse instance) =>
    <String, dynamic>{
      'listLokasi': instance.listLokasi,
    };

Lokasi _$LokasiFromJson(Map<String, dynamic> json) {
  return Lokasi()
    ..nama = json['nama'] as String
    ..latitude = (json['latitude'] as num)?.toDouble()
    ..longitude = (json['longitude'] as num)?.toDouble()
    ..alamat = json['alamat'] as String
    ..foto = json['foto'] as String
    ..telepon = json['telepon'] as String;
}

Map<String, dynamic> _$LokasiToJson(Lokasi instance) => <String, dynamic>{
      'nama': instance.nama,
      'latitude': instance.latitude,
      'longitude': instance.longitude,
      'alamat': instance.alamat,
      'foto': instance.foto,
      'telepon': instance.telepon,
    };


2. Domain
Domain is the inner layer which shouldn’t be susceptible to the whims of changing data sources or porting our app to Angular Dart. It will contain only the core business logic (use cases) and business objects (entities).

Repository classes act as the Data Layer and Domain Layer, each function on the repository class acts as the domain layer that specifies the use cases of the feature.


3. Presentation
Presentation is where the UI goes. You obviously need widgets to display something on the screen. These widgets is controlled by the state using various state management design pattern used in Flutter. In this project, I use BLoC as the state management.

BLoC allows us to know exactly what data is given to the state. There is BLoC implementation that uses event classes to easily predict what state is the application in, but I use the simpler implementation of BLoC (just using streams) to shorten times for other that hasn’t been familiar to BLoC before. But I won’t dive too deep on BLoC because it’s another thing to write (but if you are curious you can read it here).

Something that I want to point out is about using Stream. Stream allows your application to run asynchronously. Imagine stream as a river and the data is the water, so you can always add more data, or in this case, state, and stream will send the data to your UI using StreamBuilder. You don’t just add data to the stream, but you add the data to the streams’ sink.
import 'dart:async';

import 'package:ppl_disabilitas/model/lokasi.dart';
import 'package:ppl_disabilitas/network/data/network_model.dart';
import 'package:ppl_disabilitas/repository/LokasiRepository.dart';

class LokasiResponseBloc {
  StreamController _recentSearchController;
  LokasiRepository _lokasiRepository;
  StreamController _lokasiListController;

  StreamSink<NetworkModel<LokasiListResponse>> get recentSearchSink =>
      _recentSearchController.sink;
  Stream<NetworkModel<LokasiListResponse>> get recentSearchStream =>
      _recentSearchController.stream;

  StreamSink<NetworkModel<LokasiListResponse>> get lokasiListSink =>
      _lokasiListController.sink;
  Stream<NetworkModel<LokasiListResponse>> get lokasiListStream =>
      _lokasiListController.stream;

  LokasiResponseBloc() {
    _lokasiListController =
        StreamController<NetworkModel<LokasiListResponse>>();
    _recentSearchController = StreamController<NetworkModel<LokasiListResponse>>();
    _lokasiRepository = LokasiRepository();
    fetchLokasiList();
    fetchRecentSearch();
  }

  fetchLokasiList() async {
    lokasiListSink.add(NetworkModel.loading('Getting Locations'));
    try {
      final lokasiListResponse =
          await _lokasiRepository.fetchLokasi();
      lokasiListSink.add(NetworkModel.completed(lokasiListResponse));
    } catch (e) {
      lokasiListSink.add(NetworkModel.error(e.toString()));
    }
  }

  fetchRecentSearch() async {
    recentSearchSink.add(NetworkModel.loading('Getting Recent Search'));
    try {
      final recentSearchData = await _lokasiRepository.fetchRecentSearch();
      recentSearchSink.add(NetworkModel.completed(recentSearchData));
    } catch (e) {
      recentSearchSink.add(NetworkModel.error(e.toString()));
    }
  }

  saveRecentSearch(Lokasi search) async {
    await _lokasiRepository.saveRecentSearch(search);
  }

  dispose() {
    _recentSearchController?.close();
    _lokasiListController?.close();
  }
}

class Pencarian extends StatefulWidget {
  @override
  PencarianState createState() => PencarianState();
}

/// State of Pencacrian page
class PencarianState extends State<Pencarian> {
  /// Controller for textFormField
  TextEditingController myController = TextEditingController();

  /// Search Icon for textFormField
  Icon searchIcon = Icon(Icons.search);

  /// Text for appbar
  Widget appBarText = Text('Pencarian Lokasi');

  /// List of places currently searched on the textFormField
  List<Lokasi> currentSearch = [];

  /// List for places from API
  List<Lokasi> places = [];

  /// BLoC for pencarian
  LokasiResponseBloc _bloc = LokasiResponseBloc();


  @override
  Widget build(BuildContext context) {
    return Scaffold(
      appBar: AppBar(
        backgroundColor: greenPrimary,
        leading: IconButton(
            icon: Icon(Icons.arrow_back_ios, size: 25),
            key: Key('Back Icon Key'),
            onPressed: () => Navigator.pop(context, 'Take me back')),
        title: Container(
          margin: EdgeInsets.only(top: doubleSpace, bottom: doubleSpace),
          decoration: BoxDecoration(
              color: Colors.white,
              borderRadius: doubleBorderRadius,
              boxShadow: regularShadow),
          child: TextFormField(
            controller: myController,
            key: Key('Text Field Mau Kemana'),
            decoration: InputDecoration(
                contentPadding: EdgeInsets.all(0),
                isDense: false,
                prefixIcon: Icon(
                  Icons.search,
                  color: greenPrimary,
                  size: 25,
                ),
                border: InputBorder.none,
                fillColor: Colors.white,
                labelText: 'Kamu mau kemana?',
                labelStyle: TextStyle(
                    color: greenPrimary,
                    fontSize: 18,
                    fontFamily: 'Muli',
                    fontWeight: FontWeight.w700),
                suffixIcon: IconButton(
                  icon: Icon(
                    Icons.mic,
                    color: greenPrimary,
                    size: 25,
                  ),
                  onPressed: () {},
                )),
          ),
        ),
      ),
      body: Column(
        crossAxisAlignment: CrossAxisAlignment.start,
        children: <Widget>[
          StreamBuilder<NetworkModel<LokasiListResponse>>(
            stream: _bloc.recentSearchStream,
            builder: (context, snapshot) {
              if (snapshot.hasData) {
                switch (snapshot.data.status) {
                  case Status.LOADING:
                    return Center(
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(greenPrimary),
                      ),
                    );
                    break;
                  case Status.COMPLETED:
                    final recentSearch = snapshot.data.data;
                    Widget displayWidget;
                    if (recentSearch.listLokasi.isEmpty) {
                      displayWidget = Center(
                          child: Text("Anda belum pernah melakukan pencarian"));
                    } else {
                      displayWidget = makeLokasiWidget(
                          "history", recentSearch.listLokasi.take(3).toList());
                    }
                    return Expanded(
                        child: Column(
                      crossAxisAlignment: CrossAxisAlignment.start,
                      children: <Widget>[
                        Container(
                            margin: EdgeInsets.all(doubleSpace),
                            child: Text(
                              "Pencarian terdahulu",
                              style:
                                  TextStyle(fontFamily: 'Muli', fontSize: 15),
                            )),
                        Flexible(child: displayWidget),
                      ],
                    ));
                    break;
                  case Status.ERROR:
                    return Center(
                      child: Text("${snapshot.data.status}"),
                    );
                    break;
                }
              }
              return Container();
            },
          ),
          Container(
            margin: EdgeInsets.only(
                left: doubleSpace, top: regularSpace, bottom: smallSpace),
            child: Text("Hasil Pencarian"),
          ),
          StreamBuilder<NetworkModel<LokasiListResponse>>(
            stream: _bloc.lokasiListStream,
            builder: (context, snapshot) {
              if (snapshot.hasData) {
                switch (snapshot.data.status) {
                  case Status.LOADING:
                    return Center(
                      child: CircularProgressIndicator(
                        valueColor: AlwaysStoppedAnimation<Color>(greenPrimary),
                      ),
                    );
                    break;
                  case Status.COMPLETED:
                    places = snapshot.data.data.listLokasi;
                    return Expanded(
                        flex: 2,
                        child: currentSearch.isEmpty
                            ? Center(child: Text('Cari lokasi'))
                            : makeLokasiWidget("api", currentSearch));
                    break;
                  case Status.ERROR:
                    return Center(
                      child: Text(snapshot.data.data.toString()),
                    );
                    break;
                }
              }
              return Container();
            },
          ),
        ],
      ),
    );
  }
}
References
https://www.youtube.com/watch?v=KjE2IDphA_U


# create home repo
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/8d975b7898895195d13456fa0e3033abd3a746df
37. Home repo

# create home repo methods and failure file
add Either class
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/09713cee56341892aac2ceee04a85c601634ea95
38. Eithere class 
# 
///
39. Use cases
# create fetch featuerd books use case
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/ff0cf6f7a2501e3210bf64a7ab8a7c733d45c7ff
40. Fetch featured books use case
# refactor to use case class
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/b01776a74d33fdf47f56116df7b6d0fd46ebd5ca
41. Generic use case
# fetch newest books use case
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/71e1a035ec892c51c0aa6681b548d210f7532be7
42. Fetch newest books use case
# create book model
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/5001410d7775b36a173a817b09f964d249a4fd78
44. Book model
Install Json to Dart Model Extension.
# 
45. Book Model part 2
#
46. Book model part 3
# 
47. Remote and local data source
# create home remote data source
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/8f58336adbc89bb642efeabd0bd3732df8aeb26c
49. Home remote data source
# implemnt remote fetch featured books
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/f41ce0696f5dda04551b0290056f4f1a7b2a2e91
https://www.googleapis.com/books/v1/volumes?q=prohramming
https://www.googleapis.com/books/v1/volumes?=Filtering=free-ebooks&q=prohramming
50. Implement remote fetch featured books
# implement remote fetch newest books
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/23725f06be60a3f96ac306e686b18e2ccf57b113
https://www.googleapis.com/books/v1/volumes?=Filtering=free-ebooks&Sorting=newest&q=prohramming
51. Implement remote fetch newest books
# create home local data source
# add hive to project
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/e674152287f9aa8c7a3c1b8e6469ea0d4f6c5b7e
52. Create local data source and add hive
# generate book entity adapter
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/96f14070b0ab21bb7b6e44ae04322b451206cf46
Command
PS C:\Users\sacid\Documents\myproject\clean_arch_bookly_app_v1> flutter pub run build_runner build non Fonctionnelle 
flutter pub run build_runner build --delete-conflicting-outputs FONCTIONNELLE COMMAND
53. Generate book entity adapter
# register adapter and open featured box
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/cbed29b2fc77adfbfff533840beb9368f677a8b3
54. Register book entity adapter and open featured box
# cache featured books
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/d20e7ef76c40da0715c0c4dceb47d09daee92d34
55. Cache featured books
# implement fetch featured box local data source
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/08a9462979c3505fb005e611e3aa779ecf64c9c7
56. Fetch featured books local data source
# cache newest books
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/dabbc7f67da28a3f9174977c651eed86abc283d6
57. Fetch newest books local data source
# create home repo impl
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/c30689e754c4d6138066e7578d8439e97647d038
58. Home repo impl
59. Fetch featured books home repo impl
# some minor refactor in home repo impl
# create server failure from dio error
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/1261b843118793e7de3c2bdf59a826ee62776736
61. Server failure part 1
62. Server failure part 2
# careate featured books states
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/a3555964fc7334a33dbdd94c1a8a81663ec02dd0
64. Fetch featured books cubit states
# implemtn cubit featch featured books
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/9d81f644873d60fee543bab6a447c8fc5b655b11
65. Implement cubit fetch featured books method
# create newest books cubit
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/ce7a1f0b3f640374fbe297787a836f70c333d6dc
66. Create fetch newest books
# create simple bloc observer
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/d78a2055aa1ffe43720b28867bae40a1c610e0cb
67. Bloc Provider
68. Get it part 1
# create service locator
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/e98e7dbe4534ee287d0361e69dbb3f79e1f8d760
69. Get it part 2
# create simple bloc observer
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/d78a2055aa1ffe43720b28867bae40a1c610e0cb
70. Bloc observer
# integrate featured books cubit
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/acb2a333dbb5a16edfdd95d9d263bccb3815199b
71. Integrate fetch featured books cubit
71. Integrate fetch Newested books cubit
# display featured books list view data
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/6321273cb48b735161dc7017c18123b9cd92e221
72. Display featured books data

# refactor fetch featured books request
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/c84e9db40886b7e7a17749b799e89f65ceab0a82
74. Pagination part 2
# pagination part 1
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/53186e93d8308d12aa3277132b461cdedcc7dd34
75. Pagination part 3

{ chatGpt 4 }
trigger this request FeaturedBooksListView when this list view "class FeaturedBooksListView extends StatelessWidget {
  const FeaturedBooksListView({super.key, required this.books});
  final List<BookEntity> books;
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: MediaQuery.of(context).size.height * .3,
      child: ListView.builder(
        itemCount: books.length,
        scrollDirection: Axis.horizontal,
        itemBuilder: (context, index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: CustumBookImage(
              image: books[index].image ?? '',
            ),
          );
        },
      ),
    );
  } " reaches 70% of it's lenght

 import 'package:flutter/material.dart';

class FeaturedBooksListView extends StatefulWidget {
  @override
  _YourStatefulWidgetState createState() => _YourStatefulWidgetState();
}

class _YourStatefulWidgetState extends State<YourStatefulWidget> {
  ScrollController _scrollController;

  @override
  void initState() {
    super.initState();
    _scrollController = ScrollController();
    _scrollController.addListener(_checkListLength);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _checkListLength() {
    final maxScrollExtent = _scrollController.position.maxScrollExtent;
    final currentExtent = _scrollController.position.extentBefore;
    final threshold = 0.7; // 70% of the list's length

    if (currentExtent >= maxScrollExtent * threshold) {
      // The list has reached 70% of its length, trigger the request here
      // Example code: FeaturedBooksListView().triggerRequest()
    }
  }

  @override
  Widget build(BuildContext context) {
    return ListView.builder(
      controller: _scrollController,
      itemCount: books.length,
      scrollDirection: Axis.horizontal,
      itemBuilder: (context, index) {
        return Padding(
          padding: const EdgeInsets.symmetric(horizontal: 8),
          child: CustomBookImage(
            image: books[index].image ?? '',
          ),
        );
      },
    );
  }
}



/////////////////////////////////////{ chatGpt 4 }/////////////////////////////////////
trigger this request fetchfeaturedBook when this list view 'class FeaturedBooksListView extends StatelessWidget {
  const FeaturedBooksListView({super.key, required this.books});
  final List<BookEntity> books;
  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: MediaQuery.of(context).size.height * .3,
      child: ListView.builder(
        itemCount: books.length,
        scrollDirection: Axis.horizontal,
        itemBuilder: (context, index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: CustumBookImage(
              image: books[index].image ?? '',
            ),
          );
        },
      ),
    );
  }
}'   reaches 70% of it's lenght
//////////////////////////////////////{ chatGpt 4 }/////////////////////////////////

1/1

To trigger the function `fetchfeaturedBook` when the `FeaturedBooksListView` reaches 70% of its length, you can add a ScrollController which listens to the ListView's scroll events and alerts when the list has been scrolled to its 70% size.

Below is a sample code snippet that demonstrates how you can implement this:

```dart
import 'package:flutter/material.dart';

class FeaturedBooksListView extends StatefulWidget {
  final List<BookEntity> books;

  const FeaturedBooksListView({super.key, required this.books});

  @override
  _FeaturedBooksListViewState createState() => _FeaturedBooksListViewState();
}

class _FeaturedBooksListViewState extends State<FeaturedBooksListView> {
  final ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(_onScroll);
  }

  @override
  void dispose() {
    _scrollController.dispose();
    super.dispose();
  }

  void _onScroll() {
    if (_scrollController.position.pixels >
        _scrollController.position.maxScrollExtent * 0.7) {
      fetchfeaturedBook();
    }
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: MediaQuery.of(context).size.height * .3,
      child: ListView.builder(
        controller: _scrollController,
        itemCount: books.length,
        scrollDirection: Axis.horizontal,
        itemBuilder: (context, index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: CustumBookImage(
              image: books[index].image ?? '',
            ),
          );
        },
      ),
    );
  }
}
```

In this updated version of the widget, the `_onScroll` function is executed every time the user scrolls the list. When the current scroll position reaches 70% of the maximum scroll extent, it triggers the `fetchfeaturedBook` function. Don't forget to implement the `fetchfeaturedBook` function according to your requirements.
Please note that this will trigger the function every time the user scrolls past 70% point. If you want `fetchfeaturedBook` to be called only once, then you would have to incorporate additional check in `_onScroll` method.  

//////////////////////////////////////////{ chatGpt 4 }//////////////////////////////////////

2/2 

To initiate the `fetchfeaturedBook` request when the `FeaturedBooksListView` List View reaches 70% of its length, you would want to use a ScrollController to listen to scroll events for the ListView. Here's an example of how you can do this:

```dart
class FeaturedBooksListView extends StatefulWidget {
  FeaturedBooksListView({super.key, required this.books});
  final List<BookEntity> books;

  @override
  _FeaturedBooksListViewState createState() => _FeaturedBooksListViewState();
}

class _FeaturedBooksListViewState extends State<FeaturedBooksListView> {

  ScrollController _scrollController = ScrollController();

  @override
  void initState() {
    super.initState();
    _scrollController.addListener(() {
      if (_scrollController.position.pixels >
          _scrollController.position.maxScrollExtent * 0.7) {
        // fetchfeaturedBook request goes here
      }
    });
  }

  @override
  Widget build(BuildContext context) {
    return SizedBox(
      height: MediaQuery.of(context).size.height * .3,
      child: ListView.builder(
        controller: _scrollController,
        itemCount: widget.books.length,
        scrollDirection: Axis.horizontal,
        itemBuilder: (BuildContext context, int index) {
          return Padding(
            padding: const EdgeInsets.symmetric(horizontal: 8),
            child: CustumBookImage(
              image: widget.books[index].image ?? '',
            ),
          );
        },
      ),
    );
  }
}
```

In the `initState` method of `_FeaturedBooksListViewState`, the ScrollController `_scrollController` adds a listener that checks if the ListView has been scrolled to 70% of its length. If it has, it initiates the `fetchfeaturedBook` request. You'll want to replace the code comment with your code to fetch the books.

Note that we changed `FeaturedBooksListView` to a StatefulWidget to properly manage the ScrollController's lifecycle. The ScrollController should be disposed in a `dispose` method to prevent memory leaks:

```dart
@override
void dispose() {
  _scrollController.dispose();
  super.dispose();
}
```

Be aware that continuous scrolling can trigger the fetch multiple times in this setup. Depending on your requirement, you might want to add a flag to prevent multiple triggers or initiate fetching the next batch of books.  
//////////////////////////////////////////{ chatGpt 4 }//////////////////////////////////////

# pagination part 1
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/53186e93d8308d12aa3277132b461cdedcc7dd34
# paginate local featch featured books
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/f5769d0e07da76a0789584e68423dc945a590f8c
76. Pagination part 4

# fix error with pagination
https://github.com/tharwatsamy/clean_arch_bookly_app/commit/0228ce32ff80896bc15e04d286bee1f9f4a532c2
77. Fix error with pagination